---
title: nextjs实践
name: Z.C Yang
date: 2025-10-06 10:00:00 -0500
categories: [前端]
tags: [react, nextjs]
---

## Next.j s网站生成技术

- 静态网站生成（Static Site Generation，简称SSG）

SSG是一种在构建时生成HTML的技术，网站内容会在部署时生成，这种方式速度极快，还能通过CDN加速分发, 这种方案并不适合需要频繁更新内容的网站。

Next.js默认采用静态渲染策略，生成结果会被缓存并通过CDN网络分发，博客、技术文档或营销页面这类场景。


- 增量静态再生（简称ISR）方案

在网站构建完成后，仍能更新静态内容。其原理是在构建阶段生成静态页面，系统会重新生成或更新这些静态页面，简言之，它兼具静态生成的优点和内容实时更新的能力。

如果想采用ISR（增量静态再生）方案，第一种是定时重新验证，只需导出revalidate配置变量，设定以秒为单位的间隔时间，即可修改页面渲染方案，操作极其简便；
```js
export const revalidate = 3600;

export default async function Page() {
  const data = await fetch("https://api.vercel.app/blog")
  const posts = await data.json();

  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
          {
            posts.map((post) => (
              <li key={post.id}>{post.title}</li>
            ))
          }
      </ul>
    </main>
  )
}

```


第二种是手动触发更新，大概如下所示：

```js
export default async function Page() {
  const data = await fetch("https://api.vercel.app/blog", {
    next: { revalidate: 3600 }
  })

  const posts = await data.json();

  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
          {
            posts.map((post) => (
              <li key={post.id}>{post.title}</li>
            ))
          }
      </ul>
    </main>
  )
}

```

这两种方式的区别在于：
第一种会设置整个页面的缓存重验时间，系统会每小时自动重新校验，第二种方案则采用下次校验的配置项，上述实例数据抓取特别设置了一小时的校验间隔，即该特定数据抓取操作，页面其他模块或其他数据抓取，则完全不受此设置影响。除定时触发外，还可利用`revalidatePath`和`revalidateTag`功能手动发起校验：

```js
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  // Invalidate the posts route in the cache
  revalidatePath('/posts')
}
```

这种方案特别适合内容会变化的网站，虽然偶尔更新，但不需要实时同步。


- 服务端渲染（SSR）

服务端渲染会实时响应用户请求，针对每个用户，而非仅针对每次部署，能确保内容始终是最新的，非常适合高度动态的内容。

服务端渲染（SSR）同样可以配置基于时间的重新验证，设置为0, Next.js会在每次用户请求时重新渲染页面。
```js
export const revalidate = 0;

export default async function Page() {
  const data = await fetch("https://api.vercel.app/blog")
  const posts = await data.json();
}
```

针对特定请求，可采用cache no-store缓存策略


- 部分预渲染（PPR）技术

该技术整合了静态渲染与动态渲染的创新方案，支持在流式传输动态内容时，同步生成页面静态框架。PPR的核心优势在于支持混合渲染模式，可在单页面内实现，突破了传统页面级渲染的限制。

PPR在构建阶段的运行机制为：
静态框架包含页面布局及所有静态内容，具体实现方式是用suspense标签包裹动态组件。用户请求页面时，会立即返回静态框架，动态内容就绪后，会以流式传输逐步加载。


## next.js接口

下面为一个book增删改查实例，其目录结构为：
```
api 
 - book
   - [id]
     - route.ts
   - db.ts
   - route.ts
```

mock数据文件为：
```js
const books = [
    { id: 1, name: "Atomic Habits" },
    { id: 2, name: "Deep Work" },
    { id: 3, name: "The 7 Habits of Highly Effective People" },
]

export default books;
```

book/route.ts文件中包含查、增接口：
```js
import books from "@/app/api/db";

export async function GET() {
    return Response.json(books);
}

export async function POST(request: Request) {
    console.log('POST')
    const book = await request.json();
    books.push(book);
    return Response.json(books);
}
```

book/[id]/route.ts包含改、删接口：
```js
import books from "@/app/api/db"

export async function PUT(request: Request, context: { params: { id: string } }) {
    const params = await context.params;
    const id = +params.id
    const book = await request.json();

    const index = books.findIndex((b) => b.id === id)
    books[index] = book;
    return Response.json(books);
}

export async function DELETE(request: Request, context: { params: { id: string } }) {
    const params = await context.params;
    const id = +params.id

    const index = books.findIndex((b) => b.id === id)
    books.slice(index, 1)
    return Response.json(books);
}
```

## SEO优化

主要讲述Next.js中如何使用元数据提升SEO效果。"元数据"，特指我们网站的整体视觉风格用户体验，或是发布到各类平台的一些相关配置。

在Next.js应用中，有两种方式来管理元数据，第一种是配置式管理，只需在布局文件中创建一个JavaScript对象，Next.js会自动识别这个对象，并将其转换为对应路由的元标签，在这个对象可以配置标题、描述、缩略图等多种元素：

```js
export const metadata = {
  title: "Home | Next.js",
  description: "Generated by create next app",
  openGraph: {
    ...openGraphImage,
    title: 'Home',
  }
}

```


在app/layout.tsx文件里如果已有基础配置，再补充新的元数据配置，系统会优先采用这个配置，这将覆盖全局中的默认配置，这样就能为每个路由单独定义元数据。


某些情况下，元数据需要根据页面具体内容动态生成，可以通过导出一个新的异步函数generateMetadata来实现，下面演示了这个策略示例：
```js
export async function generateMetadata({ params }) {
  const { id } = params;
  const resource = await getResourceById({ id } );

  return {
    title,
    description: seoDescription,
    other: {
      "og:title": title,
      "og:description": seoDescription,
      "og:image": resource.image,
      "og:title": title,
      "og:image": resource.image,
      "og:description": seoDescription,
    }
  }
}

export default function Page({ params, searchParams }) {
  ...
}
```

Next.js还支持通过文件方式来设置元数据，即直接在目录中放入相应文件即可，例如robots.txt、站点地图xml、网站图标icon、Open Graph图片等，Next.js会自动识别并自动添加到网页的meta标签中，文件名必须符合规范要求。




